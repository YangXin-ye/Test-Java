# 准备工作

## 数据库

```sql
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    image VARCHAR(255) COMMENT '商品图片',
    name VARCHAR(255) COMMENT '商品名称',
    rating DECIMAL(3, 2) COMMENT '商品评分',
    favorites INT COMMENT '商品收藏量',
    price DECIMAL(10, 2) COMMENT '商品价格',
    sales INT COMMENT '商品销量'
);

CREATE TABLE categories (
  id int NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT '分类表 id',
  p_id int DEFAULT NULL COMMENT '商品表 id',
  categoryname varchar(255) COMMENT '分类名称',
  season varchar(255) COMMENT '所属季节'
)

CREATE TABLE category_tempalte  (
  id int NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT '模版表 id',
  categoryname varchar(255) COMMENT '分类名称',
  season varchar(255) COMMENT '所属季节',
)
```

product是正常的商品数据表，categories是分类和product的关系表，category_tempalte是模板表，只用来展示有哪些分类的数据

## 前后端

快速利用代码生成器来创建对应的后端文件，复制之前的前端生成最基础的前后端的页面

# 商品分类的添加

## 问题

现在我在前端添加了一个选项叫`商品分类`，但是商品分类并不是属于商品表的我该如何解决？

![image-20240628090330383](./images/image-20240628090330383.png)

### 修改样式

在表格中代码

```html
<el-table-column prop="categoryName" label="商品分类" width="180" header-align="center" align="center">
</el-table-column>
```

## 后端

修改查询接口 Products 类中添加 categoryName 商品分类属性

```java
@Data
@EqualsAndHashCode(callSuper = false)
public class Products implements Serializable {

    //......新增属性

    /**
     * 商品分类
     */
    @TableField(exist = false)
    private String categoryName;


}
```

# 商品分类名称的多个展示

## 问题

我现在希望`商品列表`模块中的`商品分类`的数据可以展示很多个，比如`甜点、热饮`

## 后端

修改 ProductsServiceImpl 中的 listUserPage 方法

```java
    @Service
public class ProductsServiceImpl extends ServiceImpl<ProductsMapper, Products> implements ProductsService {

    //新增的属性
    @Autowired
    private CategoriesService categoriesService;

 @Override
    public Page<Products> listProductPage(Integer pageNum, Integer pageSize, ListProductsPageReq listProductsPageReq) {
        LambdaQueryWrapper<Products> lambdaQuery = Wrappers.<Products>lambdaQuery();
        lambdaQuery.like(StrUtil.isNotBlank(listProductsPageReq.getName()), Products::getName, listProductsPageReq.getName());

        Page<Products> page = new Page<>(pageNum, pageSize);
        Page<Products> resultPage = baseMapper.selectPage(page, lambdaQuery);

        List<Products> records = resultPage.getRecords();

        for (Products record : records) {
            List<Categories> list = categoriesService.lambdaQuery().eq(Categories::getPId, record.getId()).list();
            if(CollectionUtils.isNotEmpty(list)){
                List<String> collect = list.stream().map(Categories::getCategoryname).collect(Collectors.toList());
                record.setCategoryName(String.join(", ", collect));
            }
        }
        return resultPage;
    }
}
```

# 商品分类的删除

## 问题



我现在希望当我删除`分类列表`模块中的`商品分类名称`中的数据时候，对应的`商品列表`模块中的`商品分类`列表中的数据也能够被删除

## 后端

修改 CategoryTempalteServiceImpl 中的 deleteOrder 方法

```java
@Service
public class CategoryTempalteServiceImpl extends ServiceImpl<CategoryTempalteMapper, CategoryTempalte> implements CategoryTempalteService {

    @Autowired
    private CategoriesService categoriesService;
    
    @Override
    public void deleteOrder(Integer id) {
        CategoryTempalte categoryTempalte = baseMapper.selectById(id);
        String categoryname = categoryTempalte.getCategoryname();
        QueryWrapper<Categories> categoriesQueryWrapper = new QueryWrapper<>();
        categoriesQueryWrapper.eq("categoryname",categoryname);
        categoriesService.remove(categoriesQueryWrapper);
        baseMapper.deleteById(id);
    }
}
```

# 完善新增和修改

## 问题

在`商品列表`模块中的`新增`按钮和`修改`按钮应该对应不同的数据展示，点击`新增`按钮商品分类的展示应该是下拉菜单，点击`修改`按钮商品分类展示的应该是标签，并且如果没有想要的分类名称可以点击标签进行添加

## 前端

### 修改接口文件

修改 product.js 文件添加 获取标签请求接口

```js
// 获取标签数据
export const getTagList = () => {
    return http.get('/category-tempalte/categoryName')
}
```

### 完善方法

在 Product.vue 文件中 el-dialog 标签中新增商品分类标签

```html
<!-- 新增商品分类-->
<el-form-item label="商品分类">
<el-select v-model="selectedCategoryNames" multiple placeholder="请选择分类" @change="selectedCategoryChange">
  <el-option :label="item.categoryname" :value="item.categoryname" v-for="item in options"
             :key="item.id"></el-option>
</el-select>

<el-tag :key="categoryName" v-for="categoryName in form.categoryNames" closable
        :disable-transitions="false" @close="removeCategory(categoryName)">
  {{ categoryName }}
</el-tag>

<el-input ref="saveCategoryInput" class="input-new-tag" v-if="inputCategoryOpen"
          v-model="inputCategory" size="small" @keyup.enter.native="inputCategoryConfirm"
          @blur="inputCategoryConfirm">
</el-input>

<el-button v-else class="button-new-tag" size="small" @click="showInputCategory">+ New
  Tag</el-button>
</el-form-item>
```

引入 getTagList 请求

```js
import { getProductList, updateProduct, addProduct, deleteProduct ,getTagList } from '@/api/product'
```

mounted() 方法中进行初始化获取分类接口

```js
 mounted() {
    this.getProductList();
    this.getCategoriesData();
  },
```

在 Product.vue 文件中添加js基本变量属性

```js
data() {
    return {
      //...省略
      // 新增商品分类所用属性
      selectedCategoryNames: [],
      options: [],
      inputCategoryOpen: false,
      inputCategory:"",
      inputCategoryNames: new Set(),

    }
  },
```

在 Product.vue 文件中添加js方法

```js
//新增商品选择分类方法
    selectedCategoryChange(){
      this.computedCategoryNames()
    },
    removeCategory(item) {
      console.log(item)
      // 删除对应下标数据
      this.form.categoryNames.splice(this.form.categoryNames.indexOf(item), 1);
      // 同时更新下拉框
      this.selectedCategoryNames = [...this.form.categoryNames]
      // this.inputCategoryNames.delete(item)
      this.computedCategoryNames()
    },
    inputCategoryConfirm() {
      let inputValue = this.inputCategory;
      console.log("inputValue", inputValue);
      if (inputValue) {
        console.log("进入添加方法");
        this.inputCategoryNames.add(inputValue);
        this.computedCategoryNames()
      }
      this.inputCategoryOpen = false;
      this.inputCategory = '';
    },
    showInputCategory() {
      this.inputCategoryOpen = true;
      this.$nextTick(_ => {
        this.$refs.saveCategoryInput.$refs.input.focus();
      });
    },
    computedCategoryNames() {
      let categoryNames = new Set()
      if (this.selectedCategoryNames) {
        this.selectedCategoryNames.forEach(categoryName => {
          categoryNames.add(categoryName)
        })
      }

      if (this.inputCategoryNames) {
        this.inputCategoryNames.forEach(categoryName => {
          categoryNames.add(categoryName)
        })
      }
      this.form.categoryNames =  Array.from(categoryNames)
    },
    getCategoriesData() {
      getTagList().then(res => {
        console.log(res.data);
        this.options = res.data;

      })
    }
```

修改 openDialogUpdate 方法

```js
    openDialogUpdate(record) {
      // 打开窗口
      this.dialogFormVisible = true;
      this.title = '修改数据'
      this.form = {
        ...record
      }
     this.form.categoryNames =  this.form.categoryName.replace(/\s+/g, "").split(",");
    //   清空下拉选择类型
     this.selectedCategoryNames = [...this.form.categoryNames]
    },
```

## 后端

1、新增获取所有分类模板接口 CategoryTempalteController 类中新增 categoryName 方法

```java
/**
 * 获取所有分类名称
 * @return
 */
@GetMapping("/categoryName")
public Result categoryName() {
        List<CategoryTempalte> list = categoryTempalteService.list();
        return Result.success(list);
}
```

2、修改新增商品接口，需要修改为，如果新增的商品选择的商品分类不存在商品分类中，则自动进行新增到商品分类中，并且进行添加关联关系

2.1 Products 类中添加 categoryName 商品分类属性

```java
@Data
@EqualsAndHashCode(callSuper = false)
public class Products implements Serializable {

    //......新增属性

   /**
     * 新增时选择商品分类
     */
    @TableField(exist = false)
    private List<String> categoryNames;

}
```

2.2 ProductsServiceImpl 方法中新增 categoryTempalteService 属性

```java
    @Autowired
    private CategoryTempalteService categoryTempalteService;
```

2.3 ProductsServiceImpl 方法中修改 addProducts 方法

```java
    @Override
    public void addProducts(Products products) {
        //.....之前代码，省略

        // 添加商品对应分类数据
        if (CollUtil.isNotEmpty(products.getCategoryNames())) {
            List<String> categoryNames = products.getCategoryNames();
            List<Categories> insertCategories = new ArrayList<>();
            for (String categoryName : categoryNames) {
                List<Categories> list = categoriesService.lambdaQuery().eq(Categories::getCategoryname, categoryName).list();
                if(CollectionUtil.isEmpty(list)){
                    //新增
                    CategoryTempalte categoryTempalte = new CategoryTempalte();
                    categoryTempalte.setCategoryname(categoryName);
                    categoryTempalteService.save(categoryTempalte);
                    Categories categories = new Categories();
                    categories.setPId(products.getId());
                    categories.setCategoryname(categoryName);
                    insertCategories.add(categories);
                }else{
                    Categories categories = new Categories();
                    categories.setPId(products.getId());
                    categories.setCategoryname(list.get(0).getCategoryname());
                    insertCategories.add(categories);
                }
            }
            categoriesService.saveBatch(insertCategories);
        }

    }
```

2.4 ProductsServiceImpl 方法中修改 updateProduct 方法

```java
    @Override
    public void updateProduct(Products products) {
        //.....之前代码，省略
        
        
        //删除之前绑定的的分类
        QueryWrapper<Categories> categoriesQueryWrapper = new QueryWrapper<>();
        categoriesQueryWrapper.eq("p_id",products.getId());
        categoriesService.remove(categoriesQueryWrapper);
        // 如果分类名称不为空
        if (CollUtil.isNotEmpty(products.getCategoryNames())) {
            List<String> categoryNames = products.getCategoryNames();
            List<Categories> insertCategories = new ArrayList<>();
            for (String categoryName : categoryNames) {
                List<Categories> list = categoriesService.lambdaQuery().eq(Categories::getCategoryname, categoryName).list();
                if(CollectionUtil.isEmpty(list)){
                    //新增
                    CategoryTempalte categoryTempalte = new CategoryTempalte();
                    categoryTempalte.setCategoryname(categoryName);
                    categoryTempalteService.save(categoryTempalte);
                    Categories categories = new Categories();
                    categories.setPId(products.getId());
                    categories.setCategoryname(categoryName);
                    insertCategories.add(categories);
                }else{
                    Categories categories = new Categories();
                    categories.setPId(products.getId());
                    categories.setCategoryname(list.get(0).getCategoryname());
                    insertCategories.add(categories);
                }
            }
            categoriesService.saveBatch(insertCategories);
        }
    }
```

